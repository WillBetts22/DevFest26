"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContentFilterFinishReasonError = exports.LengthFinishReasonError = void 0;
exports.makeParseableResponseFormat = makeParseableResponseFormat;
exports.isAutoParsableResponseFormat = isAutoParsableResponseFormat;
exports.makeParseableTool = makeParseableTool;
exports.isAutoParsableTool = isAutoParsableTool;
exports.maybeParseChatCompletion = maybeParseChatCompletion;
exports.parseChatCompletion = parseChatCompletion;
exports.hasAutoParseableInput = hasAutoParseableInput;
exports.validateInputTools = validateInputTools;
/**
 * Create an auto-parseable response format object with brand markers.
 * Brand markers are non-enumerable properties that allow runtime detection
 * without polluting JSON serialization.
 *
 * @param response_format - The base response format object
 * @param parser - Function to parse the raw content string
 * @returns An auto-parseable response format with brand markers
 */
function makeParseableResponseFormat(response_format, parser) {
    const obj = { ...response_format };
    // Add non-enumerable brand markers
    Object.defineProperties(obj, {
        $brand: {
            value: 'auto-parseable-response-format',
            enumerable: false,
        },
        $parseRaw: {
            value: parser,
            enumerable: false,
        },
    });
    return obj;
}
/**
 * Check if a response format is auto-parseable by detecting the brand marker.
 */
function isAutoParsableResponseFormat(response_format) {
    return response_format?.['$brand'] === 'auto-parseable-response-format';
}
/**
 * Create an auto-parseable tool with brand markers.
 */
function makeParseableTool(tool, options) {
    const obj = { ...tool };
    Object.defineProperties(obj, {
        $brand: {
            value: 'auto-parseable-tool',
            enumerable: false,
        },
        $parseRaw: {
            value: options.parser,
            enumerable: false,
        },
        $callback: {
            value: options.callback,
            enumerable: false,
        },
    });
    return obj;
}
/**
 * Check if a tool is auto-parseable.
 */
function isAutoParsableTool(tool) {
    return tool?.['$brand'] === 'auto-parseable-tool';
}
/**
 * Error thrown when completion is cut off due to length limit.
 */
class LengthFinishReasonError extends Error {
    constructor() {
        super('Completion was cut off due to length limit (finish_reason: length)');
        this.name = 'LengthFinishReasonError';
    }
}
exports.LengthFinishReasonError = LengthFinishReasonError;
/**
 * Error thrown when content is filtered.
 */
class ContentFilterFinishReasonError extends Error {
    constructor() {
        super('Content was filtered due to content policy (finish_reason: content_filter)');
        this.name = 'ContentFilterFinishReasonError';
    }
}
exports.ContentFilterFinishReasonError = ContentFilterFinishReasonError;
/**
 * Parse a chat completion if it has auto-parseable inputs.
 * If no auto-parseable inputs are detected, returns the completion with null parsed fields.
 *
 * @param completion - The raw completion from the API
 * @param params - The request parameters (may be null)
 * @returns ParsedChatCompletion with parsed content
 */
function maybeParseChatCompletion(completion, params) {
    if (!params || !hasAutoParseableInput(params)) {
        // No auto-parseable inputs - return completion with null parsed fields
        return {
            ...completion,
            choices: completion.choices.map((choice) => ({
                ...choice,
                message: {
                    ...choice.message,
                    parsed: null,
                    tool_calls: choice.message.tool_calls?.map((tc) => ({
                        ...tc,
                        function: {
                            ...tc.function,
                            parsed_arguments: null,
                        },
                    })),
                },
            })),
        };
    }
    return parseChatCompletion(completion, params);
}
/**
 * Parse a chat completion with auto-parseable inputs.
 * Throws errors for length or content_filter finish reasons.
 *
 * @param completion - The raw completion from the API
 * @param params - The request parameters
 * @returns ParsedChatCompletion with parsed content
 */
function parseChatCompletion(completion, params) {
    const choices = completion.choices.map((choice) => {
        // Throw on problematic finish reasons
        if (choice.finish_reason === 'length') {
            throw new LengthFinishReasonError();
        }
        if (choice.finish_reason === 'content_filter') {
            throw new ContentFilterFinishReasonError();
        }
        return {
            ...choice,
            message: {
                ...choice.message,
                tool_calls: choice.message.tool_calls?.map((toolCall) => parseToolCall(params, toolCall)),
                parsed: choice.message.content && !choice.message.refusal ?
                    parseResponseFormat(params, choice.message.content)
                    : null,
            },
        };
    });
    return { ...completion, choices };
}
/**
 * Parse the response format content if auto-parseable.
 */
function parseResponseFormat(params, content) {
    if (params.response_format?.type !== 'json_schema') {
        return null;
    }
    if ('$parseRaw' in params.response_format) {
        const response_format = params.response_format;
        return response_format.$parseRaw(content);
    }
    // Even if not auto-parseable, try to parse as JSON if strict mode
    if (params.response_format.json_schema?.strict) {
        return JSON.parse(content);
    }
    return null;
}
/**
 * Parse a tool call's arguments if the tool is auto-parseable.
 */
function parseToolCall(params, toolCall) {
    const inputTool = params.tools?.find((t) => {
        if (!t || typeof t !== 'object')
            return false;
        return ('type' in t &&
            t.type === 'function' &&
            'function' in t &&
            typeof t.function === 'object' &&
            t.function &&
            'name' in t.function &&
            t.function.name === toolCall.function.name);
    });
    let parsed_arguments = null;
    if (inputTool && isAutoParsableTool(inputTool)) {
        parsed_arguments = inputTool.$parseRaw(toolCall.function.arguments);
    }
    else if (inputTool &&
        'function' in inputTool &&
        inputTool.function &&
        typeof inputTool.function === 'object' &&
        'strict' in inputTool.function) {
        parsed_arguments = JSON.parse(toolCall.function.arguments);
    }
    return {
        id: toolCall.id,
        type: 'function',
        function: {
            name: toolCall.function.name,
            arguments: toolCall.function.arguments,
            parsed_arguments,
        },
    };
}
/**
 * Check if parameters have any auto-parseable inputs (response format or tools).
 */
function hasAutoParseableInput(params) {
    if (isAutoParsableResponseFormat(params.response_format)) {
        return true;
    }
    return (params.tools?.some((t) => {
        if (isAutoParsableTool(t))
            return true;
        if (!t || typeof t !== 'object')
            return false;
        return ('type' in t &&
            t.type === 'function' &&
            'function' in t &&
            typeof t.function === 'object' &&
            t.function &&
            'strict' in t.function &&
            t.function.strict === true);
    }) ?? false);
}
/**
 * Validate that all tools are marked as strict for auto-parsing.
 * Throws if any tool is not strict.
 */
function validateInputTools(tools) {
    for (const tool of tools ?? []) {
        if (!tool || typeof tool !== 'object') {
            throw new Error('Tool must be an object');
        }
        if (!('type' in tool) || tool.type !== 'function') {
            throw new Error(`Only 'function' tool types support auto-parsing; received type: ${'type' in tool ? tool.type : 'unknown'}`);
        }
        if ('function' in tool && typeof tool.function === 'object' && tool.function) {
            const func = tool.function;
            const funcName = 'name' in func ? String(func.name) : 'unknown';
            const isStrict = 'strict' in func && func.strict === true;
            if (!isStrict) {
                throw new Error(`Tool '${funcName}' must be marked with 'strict: true' for auto-parsing. ` +
                    `Only strict function tools can be auto-parsed.`);
            }
        }
    }
}
//# sourceMappingURL=parser.js.map