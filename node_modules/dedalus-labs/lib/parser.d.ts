import type { ResponseFormatJSONSchema } from "../resources/shared.js";
import type { Completion, CompletionCreateParams, CompletionCreateParamsBase, Choice, ChatCompletionMessage } from "../resources/chat/completions.js";
/**
 * Type-level brand marker for auto-parseable response formats.
 * The __output type is used for type inference only.
 */
export type AutoParseableResponseFormat<ParsedT> = ResponseFormatJSONSchema & {
    __output: ParsedT;
    $brand: 'auto-parseable-response-format';
    $parseRaw(content: string): ParsedT;
};
/**
 * Extract the parsed content type from request parameters.
 * If the response_format is auto-parseable, extracts the ParsedT type.
 * Otherwise returns null.
 */
export type ExtractParsedContentFromParams<Params extends {
    response_format?: any;
}> = Params['response_format'] extends AutoParseableResponseFormat<infer P> ? P : null;
/**
 * Create an auto-parseable response format object with brand markers.
 * Brand markers are non-enumerable properties that allow runtime detection
 * without polluting JSON serialization.
 *
 * @param response_format - The base response format object
 * @param parser - Function to parse the raw content string
 * @returns An auto-parseable response format with brand markers
 */
export declare function makeParseableResponseFormat<ParsedT>(response_format: ResponseFormatJSONSchema, parser: (content: string) => ParsedT): AutoParseableResponseFormat<ParsedT>;
/**
 * Check if a response format is auto-parseable by detecting the brand marker.
 */
export declare function isAutoParsableResponseFormat<ParsedT>(response_format: any): response_format is AutoParseableResponseFormat<ParsedT>;
/**
 * Type-level brand marker for auto-parseable tools.
 */
export type AutoParseableTool<OptionsT extends {
    name: string;
    arguments: any;
    function?: Function;
}> = {
    type: 'function';
    function: {
        name: string;
        parameters?: Record<string, unknown>;
        description?: string;
        strict?: any;
    };
    __arguments: OptionsT['arguments'];
    __name: OptionsT['name'];
    $brand: 'auto-parseable-tool';
    $callback: ((args: OptionsT['arguments']) => any) | undefined;
    $parseRaw(args: string): OptionsT['arguments'];
};
/**
 * Create an auto-parseable tool with brand markers.
 */
export declare function makeParseableTool<OptionsT extends {
    name: string;
    arguments: any;
    function?: Function;
}>(tool: any, options: {
    parser: (args: string) => OptionsT['arguments'];
    callback: ((args: any) => any) | undefined;
}): AutoParseableTool<OptionsT>;
/**
 * Check if a tool is auto-parseable.
 */
export declare function isAutoParsableTool(tool: any): tool is AutoParseableTool<any>;
/**
 * Parsed chat completion with typed parsed field.
 */
export interface ParsedChatCompletion<ParsedT> extends Omit<Completion, 'choices'> {
    choices: ParsedChoice<ParsedT>[];
}
/**
 * Parsed choice with typed parsed content.
 */
export interface ParsedChoice<ParsedT> extends Omit<Choice, 'message'> {
    message: ParsedMessage<ParsedT>;
}
/**
 * Parsed message with typed parsed field and parsed tool calls.
 */
export interface ParsedMessage<ParsedT> extends Omit<ChatCompletionMessage, 'tool_calls'> {
    /**
     * The parsed structured output, if response_format was auto-parseable.
     * Null if parsing failed or content was filtered.
     */
    parsed: ParsedT | null;
    /**
     * Tool calls with parsed arguments.
     */
    tool_calls?: ParsedFunctionToolCall[];
}
/**
 * Function tool call with parsed arguments.
 */
export interface ParsedFunctionToolCall {
    id: string;
    type: 'function';
    function: {
        name: string;
        arguments: string;
        /**
         * Parsed arguments if the tool was auto-parseable or marked as strict.
         * Null if parsing failed or tool wasn't parseable.
         */
        parsed_arguments: any | null;
    };
}
/**
 * Error thrown when completion is cut off due to length limit.
 */
export declare class LengthFinishReasonError extends Error {
    constructor();
}
/**
 * Error thrown when content is filtered.
 */
export declare class ContentFilterFinishReasonError extends Error {
    constructor();
}
/**
 * Parse a chat completion if it has auto-parseable inputs.
 * If no auto-parseable inputs are detected, returns the completion with null parsed fields.
 *
 * @param completion - The raw completion from the API
 * @param params - The request parameters (may be null)
 * @returns ParsedChatCompletion with parsed content
 */
export declare function maybeParseChatCompletion<Params extends CompletionCreateParams | null, ParsedT = Params extends null ? null : ExtractParsedContentFromParams<NonNullable<Params>>>(completion: Completion, params: Params): ParsedChatCompletion<ParsedT>;
/**
 * Parse a chat completion with auto-parseable inputs.
 * Throws errors for length or content_filter finish reasons.
 *
 * @param completion - The raw completion from the API
 * @param params - The request parameters
 * @returns ParsedChatCompletion with parsed content
 */
export declare function parseChatCompletion<Params extends CompletionCreateParams, ParsedT = ExtractParsedContentFromParams<Params>>(completion: Completion, params: Params): ParsedChatCompletion<ParsedT>;
/**
 * Check if parameters have any auto-parseable inputs (response format or tools).
 */
export declare function hasAutoParseableInput(params: CompletionCreateParams): boolean;
/**
 * Validate that all tools are marked as strict for auto-parsing.
 * Throws if any tool is not strict.
 */
export declare function validateInputTools(tools: CompletionCreateParamsBase['tools']): void;
//# sourceMappingURL=parser.d.ts.map