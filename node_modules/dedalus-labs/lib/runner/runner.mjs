// ==============================================================================
//                  © 2025 Dedalus Labs, Inc. and affiliates
//                            Licensed under MIT
//           github.com/dedalus-labs/dedalus-sdk-typescript/LICENSE
// ==============================================================================
import { createToolHandler } from "./tools.mjs";
import { accumulateToolCalls } from "./streaming.mjs";
import { buildInitialMessages, coerceToolCall } from "./messages.mjs";
import { buildRequestKwargs, normalizeModelSpec } from "./validation.mjs";
import { jsonify } from "../utils/format.mjs";
import { loggerFor } from "../../internal/utils/log.mjs";
function createLogger(client, verbose, debug) {
    const logger = loggerFor(client);
    return {
        step: (step, max) => {
            if (verbose)
                logger.info(`[DedalusRunner] Step ${step}/${max}`);
        },
        models: (requested, previous) => {
            if (!verbose)
                return;
            const current = Array.isArray(requested) ? requested.join(', ') : String(requested);
            if (previous == null) {
                logger.info(`[DedalusRunner] Calling model: ${current}`);
            }
            else {
                const prev = Array.isArray(previous) ? previous.join(', ') : String(previous);
                if (prev !== current) {
                    logger.info(`[DedalusRunner] Handoff to model: ${current}`);
                }
            }
        },
        toolSchema: (toolNames) => {
            if (verbose && toolNames.length) {
                logger.info(`[DedalusRunner] Local tools available: ${toolNames.join(', ')}`);
            }
        },
        toolExecution: (name, result, error = false) => {
            if (!verbose)
                return;
            const stringified = jsonify(result);
            const summary = stringified.length <= 80 ? stringified : stringified.slice(0, 79) + '…';
            const verb = error ? 'errored' : 'returned';
            logger.info(`[DedalusRunner] Tool ${name} ${verb}: ${summary}`);
        },
        messagesSnapshot: (messages) => {
            if (!(verbose && debug))
                return;
            logger.debug('[DedalusRunner] Conversation so far:');
            messages.slice(-6).forEach((msg, idx) => {
                const role = msg.role ?? '?';
                const content = msg.content;
                let snippet;
                if (Array.isArray(content)) {
                    snippet = '[array content]';
                }
                else {
                    const str = jsonify(content ?? '');
                    snippet = str.length <= 60 ? str : str.slice(0, 59) + '…';
                }
                logger.debug(`  [${idx}] ${role}: ${snippet}`);
            });
        },
        finalSummary: (models, tools) => {
            if (!verbose)
                return;
            const modelNames = models.map((m) => (typeof m === 'string' ? m : m.model));
            logger.info(`[DedalusRunner] Models used: ${modelNames.join(', ')}`);
            logger.info(`[DedalusRunner] Tools called: ${tools.join(', ')}`);
        },
    };
}
export class RunResult {
    constructor(finalOutput, toolResults, stepsUsed, conversationHistory = [], toolsCalled = [], modelsUsed = []) {
        this.finalOutput = finalOutput;
        this.toolResults = toolResults;
        this.stepsUsed = stepsUsed;
        this.conversationHistory = conversationHistory;
        this.toolsCalled = toolsCalled;
        this.modelsUsed = modelsUsed;
    }
    get output() {
        return this.finalOutput;
    }
    get content() {
        return this.finalOutput;
    }
    toInputList() {
        return [...this.conversationHistory];
    }
}
/** Client wrapper with local tool execution and multi-turn conversation support. */
export class DedalusRunner {
    constructor(client, verbose = false) {
        this.client = client;
        this.verbose = verbose;
    }
    /** Executes conversation with automatic tool calling up to maxSteps. */
    async run(params) {
        const { input, tools, messages, instructions, model, maxSteps = 10, mcpServers, stream = false, transport = 'http', autoExecuteTools = true, verbose, debug, returnIntent = false, ...apiParams } = params;
        if (!model)
            throw new Error('model must be provided');
        if (transport !== 'http')
            throw new Error('DedalusRunner currently supports only HTTP transport');
        if (returnIntent) {
            console.warn('`returnIntent` is deprecated; use autoExecuteTools=false to inspect raw tool_calls.');
        }
        const toolHandler = createToolHandler(tools ?? []);
        const logger = createLogger(this.client, this.verbose ?? !!verbose, !!debug);
        logger.toolSchema(toolHandler.listNames());
        const modelSpec = normalizeModelSpec(model);
        const requestKwargs = buildRequestKwargs(apiParams);
        const state = {
            model: modelSpec,
            requestKwargs,
            autoExecuteTools,
            maxSteps: Math.max(1, maxSteps),
            mcpServers: Array.from(mcpServers ?? []),
            logger,
            toolHandler,
            stream: Boolean(stream ?? false),
        };
        const conversation = buildInitialMessages({
            instructions,
            input,
            messages,
        });
        if (stream) {
            return this.runStreaming(conversation, state);
        }
        return await this.runTurns(conversation, state);
    }
    /** Executes synchronous multi-turn conversation with tool support. */
    async runTurns(conversation, state) {
        const history = [...conversation];
        const toolSchemas = state.toolHandler.schemas() || null;
        let finalText = '';
        const toolResults = [];
        const toolsCalled = [];
        const modelsUsed = [];
        let previousModel = null;
        let steps = 0;
        while (steps < state.maxSteps) {
            steps += 1;
            state.logger.step(steps, state.maxSteps);
            state.logger.messagesSnapshot(history);
            state.logger.models(state.model, previousModel);
            const modelSpec = Array.isArray(state.model) ? state.model[0] : state.model;
            if (modelSpec && !modelsUsed.includes(modelSpec)) {
                modelsUsed.push(modelSpec);
            }
            previousModel = state.model;
            const createParams = {
                model: state.model,
                messages: history,
                tools: toolSchemas,
                mcp_servers: state.mcpServers.length ? state.mcpServers : null,
                stream: state.stream,
                ...state.requestKwargs,
            };
            const response = await this.client.chat.completions.create(createParams);
            let toolCalls = [];
            let content;
            if (state.stream) {
                const collectedToolCalls = [];
                const collectedContent = [];
                for await (const chunk of response) {
                    if (chunk.choices) {
                        const choice = chunk.choices[0];
                        const delta = choice?.delta;
                        if (delta) {
                            if (delta.tool_calls) {
                                accumulateToolCalls(delta.tool_calls, collectedToolCalls);
                            }
                            if (delta.content) {
                                collectedContent.push(delta.content);
                            }
                        }
                    }
                }
                if (collectedToolCalls.length) {
                    const localToolNames = new Set(state.toolHandler.listNames());
                    const mcpNames = collectedToolCalls
                        .map((call) => call.function?.name)
                        .filter((name) => name != null && !localToolNames.has(name));
                    const hasStreamedContent = collectedContent.length > 0;
                    // MCP tools + streamed content means server already handled execution
                    if (mcpNames.length && hasStreamedContent) {
                        finalText = collectedContent.join('');
                        if (finalText) {
                            history.push({ role: 'assistant', content: finalText });
                        }
                        break;
                    }
                    const allMcp = collectedToolCalls.every((call) => {
                        const name = call.function?.name;
                        return name != null && !localToolNames.has(name);
                    });
                    if (allMcp) {
                        toolCalls = [];
                    }
                    else {
                        toolCalls = collectedToolCalls.filter((call) => {
                            const name = call.function?.name;
                            return name != null && localToolNames.has(name);
                        });
                    }
                }
                else {
                    toolCalls = [];
                    finalText = collectedContent.join('');
                    if (finalText) {
                        history.push({ role: 'assistant', content: finalText });
                    }
                    break;
                }
            }
            else {
                const completion = response;
                if (!completion?.choices?.length)
                    break;
                const choice = completion.choices[0];
                const message = choice.message;
                toolCalls = message.tool_calls || [];
                content = message.content;
                if (!toolCalls.length) {
                    finalText = content || '';
                    if (finalText) {
                        history.push({ role: 'assistant', content: finalText });
                    }
                    break;
                }
            }
            const toolPayloads = toolCalls.map((call) => coerceToolCall(call));
            for (const payload of toolPayloads) {
                const name = payload.function?.name;
                if (name && !toolsCalled.includes(name))
                    toolsCalled.push(name);
            }
            history.push({ role: 'assistant', tool_calls: toolPayloads });
            if (!state.autoExecuteTools)
                break;
            await this.executeToolCallsSync({
                toolCalls: toolPayloads,
                toolHandler: state.toolHandler,
                history,
                toolResults,
                toolsCalled,
                step: steps,
                logger: state.logger,
            });
        }
        state.logger.finalSummary(modelsUsed, toolsCalled);
        return new RunResult(finalText, toolResults, steps, history, toolsCalled, modelsUsed);
    }
    /** Executes streaming conversation, yielding content deltas. */
    async *runStreaming(conversation, state) {
        const history = [...conversation];
        const toolSchemas = state.toolHandler.schemas() || null;
        let previousModel = null;
        let steps = 0;
        const modelsUsed = [];
        while (steps < state.maxSteps) {
            steps += 1;
            state.logger.step(steps, state.maxSteps);
            state.logger.messagesSnapshot(history);
            state.logger.models(state.model, previousModel);
            const modelSpec = Array.isArray(state.model) ? state.model[0] : state.model;
            if (modelSpec && !modelsUsed.includes(modelSpec)) {
                modelsUsed.push(modelSpec);
            }
            previousModel = state.model;
            const createParams = {
                model: state.model,
                messages: history,
                tools: toolSchemas,
                mcp_servers: state.mcpServers.length ? state.mcpServers : null,
                stream: true,
                ...state.requestKwargs,
            };
            const stream = (await this.client.chat.completions.create(createParams));
            const collectedToolCalls = [];
            const collectedContent = [];
            for await (const chunk of stream) {
                yield chunk;
                if (chunk.choices) {
                    const choice = chunk.choices[0];
                    const delta = choice?.delta;
                    if (delta) {
                        if (delta.tool_calls) {
                            accumulateToolCalls(delta.tool_calls, collectedToolCalls);
                        }
                        if (delta.content) {
                            collectedContent.push(delta.content);
                        }
                    }
                }
            }
            if (!collectedToolCalls.length) {
                const finalText = collectedContent.join('');
                if (finalText) {
                    history.push({ role: 'assistant', content: finalText });
                }
                break;
            }
            const localToolNames = new Set(state.toolHandler.listNames());
            const mcpNames = collectedToolCalls
                .map((call) => call.function?.name)
                .filter((name) => name != null && !localToolNames.has(name));
            const hasStreamedContent = collectedContent.length > 0;
            // MCP tools + streamed content means server already handled execution
            if (mcpNames.length && hasStreamedContent) {
                const finalText = collectedContent.join('');
                if (finalText) {
                    history.push({ role: 'assistant', content: finalText });
                }
                break;
            }
            const allMcp = collectedToolCalls.every((call) => {
                const name = call.function?.name;
                return name != null && !localToolNames.has(name);
            });
            if (allMcp) {
                break;
            }
            const localToolCalls = collectedToolCalls.filter((call) => {
                const name = call.function?.name;
                return name != null && localToolNames.has(name);
            });
            const toolPayloads = localToolCalls.map((call) => coerceToolCall(call));
            history.push({ role: 'assistant', tool_calls: toolPayloads });
            if (!state.autoExecuteTools)
                break;
            const toolResults = [];
            const toolsCalled = [];
            for (const toolCall of toolPayloads) {
                const name = toolCall.function?.name ?? '';
                const argsRaw = toolCall.function?.arguments;
                let args = {};
                if (argsRaw && typeof argsRaw === 'object' && !Array.isArray(argsRaw)) {
                    args = argsRaw;
                }
                else if (typeof argsRaw === 'string') {
                    try {
                        args = JSON.parse(argsRaw);
                    }
                    catch {
                        args = {};
                    }
                }
                try {
                    const result = await state.toolHandler.exec(name, args);
                    toolResults.push({ name, result, step: steps });
                    if (!toolsCalled.includes(name))
                        toolsCalled.push(name);
                    history.push({
                        role: 'tool',
                        tool_call_id: toolCall.id ?? '',
                        content: typeof result === 'string' ? result : JSON.stringify(result),
                    });
                    state.logger.toolExecution(name, result);
                }
                catch (error) {
                    history.push({
                        role: 'tool',
                        tool_call_id: toolCall.id ?? '',
                        content: `Error: ${String(error?.message ?? error)}`,
                    });
                    state.logger.toolExecution(name, error, true);
                }
            }
        }
    }
    /** Executes local tools and appends results to conversation. */
    async executeToolCallsSync({ toolCalls, toolHandler, history, toolResults, toolsCalled, step, logger, }) {
        for (const toolCall of toolCalls) {
            const name = toolCall.function?.name ?? '';
            const argsRaw = toolCall.function?.arguments;
            let args = {};
            if (argsRaw && typeof argsRaw === 'object' && !Array.isArray(argsRaw)) {
                args = argsRaw;
            }
            else if (typeof argsRaw === 'string') {
                try {
                    args = JSON.parse(argsRaw);
                }
                catch {
                    args = {};
                }
            }
            try {
                const result = await toolHandler.exec(name, args);
                toolResults.push({ name, result, step });
                if (!toolsCalled.includes(name))
                    toolsCalled.push(name);
                history.push({
                    role: 'tool',
                    tool_call_id: toolCall.id ?? '',
                    content: typeof result === 'string' ? result : JSON.stringify(result),
                });
                logger.toolExecution(name, result);
            }
            catch (error) {
                history.push({
                    role: 'tool',
                    tool_call_id: toolCall.id ?? '',
                    content: `Error: ${String(error?.message ?? error)}`,
                });
                logger.toolExecution(name, error, true);
            }
        }
    }
}
//# sourceMappingURL=runner.mjs.map