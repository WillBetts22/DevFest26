"use strict";
// ==============================================================================
//                  Â© 2025 Dedalus Labs, Inc. and affiliates
//                            Licensed under MIT
//           github.com/dedalus-labs/dedalus-sdk-typescript/LICENSE
// ==============================================================================
Object.defineProperty(exports, "__esModule", { value: true });
exports.toSchema = toSchema;
function toSchema(func, opts) {
    try {
        const name = func.name || 'anonymous';
        const description = opts?.description ||
            // try to read a JSDoc string (not reliable at runtime; kept for symmetry)
            func.description ||
            `Execute ${name}`;
        // If caller provides a schema, honor it entirely.
        if (opts?.parameters) {
            return {
                type: 'function',
                function: { name, description, parameters: opts.parameters },
            };
        }
        // Heuristic: extract parameter names from function source.
        const src = Function.prototype.toString.call(func);
        const match = src.match(/^[^(]*\(\s*([^)]*)\)/);
        const params = match?.[1] ?
            match[1]
                .split(',')
                .map((s) => s.trim())
                .filter(Boolean)
                // strip default values and rest/spread
                .map((s) => s
                .replace(/=.*$/, '')
                .replace(/^[.\s]*\.\.\./, '')
                .trim())
            : [];
        const properties = {};
        const required = [];
        if (params.length === 0) {
            // Match Python fallback: single required "input" string
            properties['input'] = { type: 'string' };
            required.push('input');
        }
        else {
            for (const p of params) {
                // Without runtime type info, default each param to string
                properties[p] = { type: 'string' };
                required.push(p);
            }
        }
        const schema = {
            type: 'object',
            properties,
            required,
            additionalProperties: false,
        };
        return {
            type: 'function',
            function: { name, description, parameters: schema },
        };
    }
    catch {
        const name = func?.name || 'anonymous';
        return {
            type: 'function',
            function: {
                name,
                description: `Execute ${name}`,
                parameters: { type: 'object', properties: {} },
            },
        };
    }
}
//# sourceMappingURL=schemas.js.map