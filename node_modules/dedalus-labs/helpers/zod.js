"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.zodResponseFormat = zodResponseFormat;
exports.zodFunction = zodFunction;
const parser_1 = require("../lib/parser.js");
const transform_1 = require("../lib/schemas/transform.js");
// Type guard to check if Zod is available
function checkZodAvailable() {
    try {
        require.resolve('zod');
    }
    catch {
        throw new Error('Zod is not installed. Install it with: npm install zod\n' +
            'Zod helpers require zod >= 3.23 as a peer dependency.');
    }
}
function zodResponseFormat(zodObject, name, props) {
    checkZodAvailable();
    // Dynamically import Zod to avoid hard dependency
    const z = require('zod');
    // Check if the zodObject is actually a Zod schema
    if (!('_def' in zodObject && typeof zodObject.parse === 'function')) {
        throw new Error('zodObject must be a Zod schema with _def and parse method');
    }
    // Use Zod's native toJSONSchema (available since v3.23)
    let jsonSchema;
    // Try Zod v4 first (has toJSONSchema static method)
    if (typeof z.toJSONSchema === 'function') {
        jsonSchema = z.toJSONSchema(zodObject, {
            target: 'draft-7',
            reused: 'ref', // Handle circular references
        });
    }
    // Try Zod v3 (has toJSONSchema on instance)
    else if ('toJSONSchema' in zodObject && typeof zodObject.toJSONSchema === 'function') {
        jsonSchema = zodObject.toJSONSchema({
            target: 'draft-7',
            reused: 'ref',
        });
    }
    // Fallback error
    else {
        throw new Error('Zod version does not support toJSONSchema(). ' + 'Please upgrade to Zod >= 3.23 or Zod v4.');
    }
    // Apply strict transformations for OpenAI compatibility
    const strictSchema = (0, transform_1.transformJSONSchema)(jsonSchema);
    return (0, parser_1.makeParseableResponseFormat)({
        type: 'json_schema',
        json_schema: {
            ...props,
            name,
            strict: true, // Schema types as object but API expects boolean
            schema: strictSchema,
        },
    }, (content) => {
        // Use Zod's parse method for validation
        try {
            const parsed = JSON.parse(content);
            return zodObject.parse(parsed);
        }
        catch (err) {
            // Type guard for Zod errors
            if (err && typeof err === 'object' && ('issues' in err || err.name === 'ZodError')) {
                const zodError = err;
                throw new Error(`Failed to parse structured output: ${zodError.message}\n` +
                    `Issues: ${JSON.stringify(zodError.issues, null, 2)}`);
            }
            throw err;
        }
    });
}
/**
 * Creates a function tool that can be auto-parsed by the SDK.
 *
 * The Zod schema will be automatically converted to JSON Schema when passed to the API.
 * The function's input arguments will also be validated against the provided schema.
 *
 * @example
 * ```ts
 * import { z } from 'zod';
 * import { zodFunction } from 'dedalus-labs/helpers/zod';
 *
 * const GetWeather = zodFunction({
 *   name: 'get_weather',
 *   parameters: z.object({
 *     location: z.string(),
 *     unit: z.enum(['celsius', 'fahrenheit']),
 *   }),
 *   description: 'Get the current weather in a location',
 *   function: async (args) => {
 *     // args is typed as { location: string; unit: 'celsius' | 'fahrenheit' }
 *     const weather = await fetchWeather(args.location, args.unit);
 *     return JSON.stringify(weather);
 *   },
 * });
 *
 * const completion = await client.chat.completions.parse({
 *   model: 'openai/gpt-5-nano',
 *   messages: [{ role: 'user', content: 'What is the weather in SF?' }],
 *   tools: [GetWeather],
 * });
 *
 * const toolCall = completion.choices[0]?.message.tool_calls?.[0];
 * console.log(toolCall?.function.parsed_arguments);
 * ```
 *
 * @param options - Tool configuration
 * @param options.name - The name of the function
 * @param options.parameters - Zod schema for the function parameters
 * @param options.description - Description of what the function does
 * @param options.function - Optional function implementation
 * @returns An auto-parseable tool
 */
function zodFunction(options) {
    checkZodAvailable();
    const z = require('zod');
    if (!('_def' in options.parameters && typeof options.parameters.parse === 'function')) {
        throw new Error('parameters must be a Zod schema with _def and parse method');
    }
    // Generate JSON Schema from Zod parameters
    let jsonSchema;
    if (typeof z.toJSONSchema === 'function') {
        jsonSchema = z.toJSONSchema(options.parameters, {
            target: 'draft-7',
            reused: 'ref',
        });
    }
    else if ('toJSONSchema' in options.parameters && typeof options.parameters.toJSONSchema === 'function') {
        jsonSchema = options.parameters.toJSONSchema({
            target: 'draft-7',
            reused: 'ref',
        });
    }
    else {
        throw new Error('Zod version does not support toJSONSchema(). ' + 'Please upgrade to Zod >= 3.23 or Zod v4.');
    }
    // Validate that the schema is an object type (required for function parameters)
    if (jsonSchema['type'] !== 'object') {
        throw new Error(`Zod schema for tool "${options.name}" must be an object type, ` +
            `but got type: ${jsonSchema['type']}`);
    }
    // Apply strict transformations
    const strictSchema = (0, transform_1.transformJSONSchema)(jsonSchema);
    return (0, parser_1.makeParseableTool)({
        type: 'function',
        function: {
            name: options.name,
            parameters: strictSchema,
            strict: true, // Schema types as object but API expects boolean
            ...(options.description ? { description: options.description } : {}),
        },
    }, {
        callback: options.function,
        parser: (args) => {
            try {
                const parsed = JSON.parse(args);
                return options.parameters.parse(parsed);
            }
            catch (err) {
                // Type guard for Zod errors
                if (err && typeof err === 'object' && ('issues' in err || err.name === 'ZodError')) {
                    const zodError = err;
                    throw new Error(`Failed to parse tool arguments for '${options.name}': ${zodError.message}\n` +
                        `Issues: ${JSON.stringify(zodError.issues, null, 2)}`);
                }
                throw err;
            }
        },
    });
}
//# sourceMappingURL=zod.js.map